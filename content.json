{"meta":{"title":"DanielFGray","subtitle":"literally words","description":null,"author":"DanielFGray","url":"http://danielfgray.github.io"},"pages":[],"posts":[{"title":"Learning Vim","slug":"vim-guide","date":"2016-05-20T05:04:26.725Z","updated":"2016-05-20T05:04:26.641Z","comments":true,"path":"computers/vim-guide/","link":"","permalink":"http://danielfgray.github.io/computers/vim-guide/","excerpt":"","keywords":null,"text":"HistoryIn the beginning, there was ed. Then Bill Joy came along on his [TODO: VT terminal?] and made a Visual Interface to ed. BasicsVi[m] is unlike most any other editor. Vim is modal. That means things you do in one mode will have a different effect than what happens in another mode. Almost every other editor will let you start typing text as soon as you open it. If you do that in Vim there’s no telling what will happen. Vim’s default mode, is normal mode, so to start typing in Vim you need to enter insert mode, which you can get to with i, but there are several other ways. To get back to normal mode you should press &lt;Esc&gt;, and to quit without saving you can run :q!, or to save and quit you can do ZZ. If you make a mistake in Vim, remember that u in normal mode is undo and &lt;C-r&gt; (read as Ctrl+r) is redo. If you’re not sure which mode you’re in, push &lt;Esc&gt; a couple times and you can guarantee you’re back in normal mode. You should really try to default back to normal mode as often as you can, and by that I mean don’t just stay in insert mode all day. MotionsI think the best thing to learn first in Vim is how to move the cursor. There are literally dozens and dozens of motions, so let’s start with some of the basics. h j k l move the cursor left, down, up, and right, respectively. h and l are easy to remember because they are at the left and right, but j and k can be easy to mix up at first, so it’s helpful to note that j kinda almost resembles a down arrow with the way the it exceeds the baseline. We can prepend a [count] to any of these, so if we want to move forward by 10 chars we can use 10l or if we want to go up 3 lines we can use 3k. But moving your cursor around by individual characters isn’t the most efficient way to do anything, even with adding a [count] it’s not much better than the arrow-keys. If we want to move the cursor to a specific character on the line we can use f F t T. f moves the cursor to the next occurrence of the next letter we give it. If we have foo bar on a line and our cursor at the beginning, we can move to the space by typing f&lt;space&gt; (where &lt;space&gt; is literally the space bar), or we can move to the b in “bar” by typing fb. So f works by moving the cursor to the next character given to it. F works similar, but instead of moving right of the cursor, it moves backwards to the left of the cursor. t is very similar to f but it moves the cursor to before the next character, so going back to our foo bar line, if we were to type tb our cursor would now be on the space. Hopefully you can guess how T works, it works like t, except it works from the left of the cursor. I remember f as “find” and t as “‘til” and their uppercase counterparts move backwards. There are then two more keys that expand on the power of f F t T, and those are ; and ,. The ; key works by repeating the last motion with f F t T, and , repeats the last f F t T but in the opposite direction. We can then prepend a [count] to any of these, so if we want to jump to the second occurrence of o from the right of the cursor we could use 2fo. Text-objectsText-objects are, for me, the most compelling feature of Vim. Let’s start with words, but first we should understand that Vim has two definitions of a word: word and WORD. WORD is the easiest to define, it’s any group of characters surrounded by whitespace, while word is slightly harder to define, it’s by ranges of similar characters. So foo b@r is two WORDs, but is four words, because the @ in b@r is it’s own separate word. I strongly suggest that you read :help WORD to see what Vim’s built-in help has to say about it (and when that gets in the way, you can close the split with &lt;C-w&gt; q, which is read as Ctrl+w then q). Now that’s out of the way, let’s learn some motions for dealing with words. w moves the cursor forward one word, and we can move backwards a word with b. Their WORD counterparts are simply the uppercase versions: W moves the cursor forward a WORD and B moves backwards a WORD. You can move to the end of a word with e, and you can move backwards a word with ge (or E and gE respectively). I think now is a good time to introduce another mode: visual mode. You can start visual mode with v, which will let you visually select regions of text starting from the cursor position, similar to holding shift in other editors. If your cursor is at the beginning of a word, you can visually select that word by typing ve. But what if your cursor isn’t at the beginning of the word? This is where Vim’s text-objects really show their true power. From any point in the word you can select the entire WORD with viW, which you could read as “visually select inside WORD”. There are, of course, many text-objects besides words. How about a sentence? We can navigate forward a sentence with ) and backwards a sentence with (. Unfortunately the syntax for selecting a sentence as a text-object differs slightly here, vis would select the sentence, because if we were to run vi) it would look for a group of parenthesis. That’s pretty key there, because I just introduced another text-object: groups of parenthesis. You can visually select inside groups of () by using either vi) or vi( (they’re both the same to Vim), and to take this one step further, you select things inside curly braces with vi}. What’s that? You want to select the curly braces as well as their contents? Well let’s visually select around them, with va}. We can take this inside/around idea to nearly any text-object. If we vaW it will select a WORD and also a whitespace character around the word. If we do vas it will also include a whitespace character around the sentence. OperatorsNow that you’ve learned a dozen motions, and learned how to select text-objects, what can you do with them? This is where operators come in. If you were to think of motions and text-objects as nouns, then operators are verbs. Deleting is an often used operation in text editing, and in Vim it’s done with d. Of course, d by itself doesn’t do anything, “delete what?” Vim asks, and waits patiently for you to tell it. It is at this point where the “composable” nature of Vim’s key-bindings shine. Any motion or text-object can almost always be chained to an operator. You want to delete the current word the cursor is on? daw. You want to delete the entire sentence? das. What if you wanted to change a word? You could diw and then use i to get to insert mode and start typing your changes, but there’s actually an operator for this: change, with c! With this you can ciw to change inside words, or you can ci) to change inside parentheses. The last operator I’m going to cover here is yank, which is done with y. Yank is similar to copy in most editors: it leaves the text intact while adding it to your clipboard. You could yank the next 3 words with y3w, or the entire paragraph with yap. Pasting is done with p which will insert the last yanked text after the cursor, or with P which will insert before the cursor. p/P also work with text deleted with d, and will also restore the text changed with c. The key take-away here is worth repeating: Any operator can be used with any motion or text-object. If you learn a new motion or a new verb, you can use it with your existing verbs or motions. Registers Macros","raw":null,"content":null,"categories":[{"name":"computers","slug":"computers","permalink":"http://danielfgray.github.io/computers/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://danielfgray.github.io/tags/vim/"},{"name":"unfinished","slug":"unfinished","permalink":"http://danielfgray.github.io/tags/unfinished/"}]},{"title":"On permutations of rudiments","slug":"rudimental-permutations","date":"2015-12-14T06:00:00.000Z","updated":"2016-06-03T17:59:30.475Z","comments":true,"path":"music/rudimental-permutations/","link":"","permalink":"http://danielfgray.github.io/music/rudimental-permutations/","excerpt":"","keywords":null,"text":"IntroductionThis post is still a work in progress, so bare with me please. If you spot any errors or have something you want to add, feel free to leave a comment below. Displacing AccentsLet’s begin with some simple exercises and warm-ups, using basic rudiments and moving the placement of an accent note forward by one note. Single Strokes1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-&gt; &gt; &gt; &gt;R-l-r-l-R-l-r-l-R-l-r-l-R-l-r-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-L-r-l-r-L-r-l-r-L-r-l-r-L-r-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-l-R-l-r-l-R-l-r-l-R-l-r-l-R-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-l-r-L-r-l-r-L-r-l-r-L-r-l-r-L- Double Strokes1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-&gt; &gt; &gt; &gt;R-r-l-l-R-r-l-l-R-r-l-l-R-r-l-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-R-l-l-r-R-l-l-r-R-l-l-r-R-l-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-r-L-l-r-r-L-l-r-r-L-l-r-r-L-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-r-l-L-r-r-l-L-r-r-l-L-r-r-l-L- Single Paradiddles1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-&gt; &gt; &gt; &gt;R-l-r-r-L-r-l-l-R-l-r-r-L-r-l-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-L-r-r-l-R-l-l-r-L-r-r-l-R-l-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-l-R-r-l-r-L-l-r-l-R-r-l-r-L-l- 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a- &gt; &gt; &gt; &gt;r-l-r-R-l-r-l-L-r-l-r-R-l-r-l-L- I’ve heard this concept also called practicing “grids”, but there’s a mathematical term for this, called permutations. PermutationsWikipedia has a page on permutations, the introduction right now says: “In mathematics, the notion of permutation relates to the act of arranging all the members of a set into some sequence or order, or if the set is already ordered, rearranging (reordering) its elements, a process called permuting.” It then goes on to describe it’s relation to set theory and computer algorithm sorting, and then a lot of math. Permutations are somewhat of an umbrella term for many ideas. Anagrams are a common form of permutations: “now”, “own”, and “won” use the same set of letters without repeating or missing any. Musical modes are another example of permutations: the steps in the major scale could be expressed as “WWHWWWH”. The Dorian mode is “WHWWWHW”, which was made by taking the first “W” and moving it to the end. All seven modes of the major scale are as follows: Ionian WWHWWWHDorian WHWWWHWPhrygian HWWWHWWLydian WWWHWWHMixolydian WWHWWHWAeolian WHWWHWWLocrian HWWHWWW I’m going to exclusively be talking about ordered permutations, which is what musical modes are, as opposed to unordered permutations, like anagrams. We’ll look at rudiments and try to make variations of them by shifting the order around. Single Paradiddle1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-R-L-R-R-L-R-L-L-R-L-R-R-L-R-L-L- Fig. 1 Now let’s take that first R and move it to the end of the pattern 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-L-R-R-L-R-L-L-R-L-R-R-L-R-L-L-R- Fig. 2 and continue the process 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-R-R-L-R-L-L-R-L-R-R-L-R-L-L-R-L- Fig. 3 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-R-L-R-L-L-R-L-R-R-L-R-L-L-R-L-R- Fig. 4 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-L-R-L-L-R-L-R-R-L-R-L-L-R-L-R-R- Fig. 5 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-R-L-L-R-L-R-R-L-R-L-L-R-L-R-R-L- Fig. 6 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-L-L-R-L-R-R-L-R-L-L-R-L-R-R-L-R- Fig. 7 1-e-&amp;-a-2-e-&amp;-a-3-e-&amp;-a-4-e-&amp;-a-L-R-L-R-R-L-R-L-L-R-L-R-R-L-R-L- Fig. 8 If we analyze these patterns, we can group them into four variations ABAA/BABB - figs. 1 and 5ABBA/BAAB - figs. 2 and 6AABA/BBAB - figs. 3 and 7ABAB/BABA - figs. 4 and 8 I prefer this form of “A/B” notation over “R/L” because it forces me to think about how to apply it. We can take any of the above four patterns and alternate them every other time between any two limbs. For any given pattern we can apply it six different ways: between both hands: right-hand / left-hand between both feet: right-foot / left-foot between both rights: right-hand / right-foot between both lefts: left-hand / left-foot diagonally one way: right-hand / left-foot diagonally the other way: left-hand / right-foot Now try all four variations across all six limb-combinations, and also practice displacing the accents. TODO:Single-stroked Hertas in three1-&amp;-a-2-&amp;-a-3-&amp;-a-4-&amp;-a-ABA-B-ABA-B-ABA-B-ABA-B- Double-stroked Hertas in three1-&amp;-a-2-&amp;-a-3-&amp;-a-4-&amp;-a-AAB-A-BBA-B-AAB-A-BBA-B-","raw":null,"content":null,"categories":[{"name":"music","slug":"music","permalink":"http://danielfgray.github.io/music/"}],"tags":[{"name":"rudiments","slug":"rudiments","permalink":"http://danielfgray.github.io/tags/rudiments/"},{"name":"drums","slug":"drums","permalink":"http://danielfgray.github.io/tags/drums/"},{"name":"permutations","slug":"permutations","permalink":"http://danielfgray.github.io/tags/permutations/"}]},{"title":"Vim beginner's customization guide","slug":"vimrc-guide","date":"2015-08-02T05:00:00.000Z","updated":"2016-05-31T23:14:18.730Z","comments":true,"path":"computers/vimrc-guide/","link":"","permalink":"http://danielfgray.github.io/computers/vimrc-guide/","excerpt":"","keywords":null,"text":"Introduction This article is for those who’ve been using Vim for a little while and have started to grasp modal editing and the powers of Vim, and now want to start customizing it. If you’re completely new to Vim, there are many resources on the internet for learning it, so I’m not going to bother with that here, I’m just gonna point you here and here. If you already have someone else’s vimrc or are using a distribution like Janus or spf13 then I suggest you delete it. You likely have no idea what it does and it means nothing to you. I’m not going to explain how to use someone else’s config, I’m going to attempt to walk you through the process of creating your own, which is much more rewarding, although do keep in my mind I’m really only going to give you my own opinions on the process and attempt to save you from some of the boring legwork of testing things out (which admittedly can also be a rewarding process). As this is not an introduction to writing Vimscript, and targeted at beginners, a lot of this is suggesting plugins. Some people don’t like plugins, and want to write their own Vimscript to do similar things as existing plugins, or just want to use vanilla Vim. I’m not exactly keen on Vim’s defaults (and I imagine neither are you if you’re reading this), and I’m not a fan of reinventing the wheel, so I have no problem with using other people’s plugins. If you’re the type to worry about how many plugins you’re using you might as well stop reading now, but keep in mind I currently use over 100 plugins and have yet to be bothered by any significant performance penalties on my modest laptop. This is written under the assumption you’re running a Linux distro, but much of this will work on Mac, and some of it on Windows too. Your mileage may vary. Initial configuration At this point I’m assuming you have no ~/.vim directory and no ~/.vimrc file. Let’s make a directory skeleton to use in your vimrc later with this command: mkdir -vp ~/.vim/&#123;autoload,bundle,cache,undo,backups,swaps&#125; Then, let’s install a plugin manager called vim-plug with this command: curl -fLo ~/.vim/autoload/plug.vim https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim (Aside: There are definitely many choices of plugin managers, but to me, vim-plug is the best of them; the syntax is very clean and it does parallel processing which makes updates so much faster than others. The other biggest contender would be NeoBundle which offers more fine-grained control, but I find the extra control is rarely needed, and vim-plug will do just about all of that anyway and with cleaner syntax. There’s also Vundle but it doesn’t have delayed loading of plugins which is a really great feature not to be missed out on.) Now, open your ~/.vimrc with Vim, and let’s use Vim-plug to install a minimal, sensible, set of default options by adding the following lines: call plug#begin('~/.vim/bundle')Plug 'tpope/vim-sensible'Plug 'shougo/vimproc', &#123;'do': 'make'&#125;call plug#end() There’s an extra plugin there called vimproc that you’ll want to let Vim do things asynchronously, or non-blocking-ly, so that things can run in the background without making Vim freeze. The second half of that tells Vim-plug to run the command make whenever it’s installed or updated. Now let’s save this file and install the plugin with this command: :w | so % | PlugInstall. You’re hopefully familiar with :ex commands like :w, :q, and :s but you may not be aware you can chain them together with |. This is equivalent to running :w, then :so % which is a shortcut for :source &lt;current filename&gt;, and then running :PlugInstall. At this point I would recommend taking a look at the options Vim-sensible defines. As you’re working/reading through this article, try to add comments to help you remember what things do later on (comments are started with &quot; but I prefer to use two of them). If you find yourself wondering what a setting does, put your cursor on the word and run :help &lt;C-r&gt;&lt;C-w&gt; (where means Ctrl+r then Ctrl+w). More sensible configurations Vim’s default nature when handling buffers is to not allow opening a new one or changing to a new buffer without saving change to the current one. Anyone who’s spent any time in another editor will likely find this incredibly annoying (at least I do), and want Vim to just remember their changes for the moment and focus on a new buffer without prompting to save first. This line will do that: set hidden I might have said this earlier, but any options you add to your vimrc are not read by the current instance, unless you run :source ~/.vimrc. You can write an autocmd to do this automatically whenever you save, but if you make a typo and save it, you’re gonna have a bad time. See the bottom if you want this functionality. This is probably a good time to let you know that if you do make a typo and your config file for some reason stops you from using Vim properly, you can tell Vim to start in ‘safe mode’ with vim -u NONE (I tend to add the -N switch also to make Vim force nocompatible mode). I quite like having line numbers in a text editor, and in recent versions there’s also relative line numbering which is great to have in Vim, since you’re most often moving around relative to your position rather than to an absolute line (which, of course, can still be done). The following lines will add line numbers and relative line numbers (or not if you’re using a version that doesn’t support it): set numberif exists('+rnu') | set relativenumber | endif If you prefer, you can split that into multiple lines where the | bars are. I’m going to suggest yet plugin (did I mention this article will be filled with lots of them?) from Tim Pope called unimpaired that adds a bunch of keybinds that, I think, should be added by default. Plug 'tpope/vim-unimpaired' With this plugin you can now toggle line numbers with con and relative numbers with cor. My most used features of this plugin are changing buffers with [b and ]b and pasting with yo/yO. You should read the list of all these key-binds by running :vert help unimpaired. I cannot stress the importance of this: you should really, really, read the help file of every plugin you add to your vimrc. You can get a list of all help files for your plugins by running :help local-additions. Another one of tpope’s great plugins is surround. This “provides mappings to easily delete, change and add such surroundings in pairs.” The README and help file does a great job of explaining how to use it so I won’t bother with that here. Plug 'tpope/vim-surround' Before I forget, and while I’m still talking about tpope, there’s yet another plugin he’s written that expands on the power of the . command which repeats the last action. . doesn’t always work with plugins, so this plugin attempts to fix that. Plug 'tpope/vim-repeat' Vim has a very powerful undo tree, which is different from the linear undo lists most editors use. Having this tree be persistent even after quitting is one of my favorite features of Vim, and so is having your :ex command history be persistent. The following lines will accomplish this: if version &gt;= 703 if exists(\"&amp;undodir\") set undodir=~/.vim/undo// endif set undofile set undoreload=10000endifset undolevels=10000if exists(\"&amp;backupdir\") set backupdir=~/.vim/backups//endifif exists(\"&amp;directory\") set directory=~/.vim/swaps//endif There’s also a plugin called gundo that I recommend adding to graphically navigate the undo tree. Vim-plug also has the ability to not load this plugin until you actually use it, although most of the time this isn’t necessary because Vim natively has on-demand loading of plugins if they’re written correctly. Plug 'sjl/gundo.vim', &#123;'on': 'GundoToggle'&#125; If you want to bind opening this to a key, you can do that with nnoremap &lt;silent&gt; &lt;F5&gt; &lt;Esc&gt;:GundoToggle&lt;CR&gt; But you can, of course, replace &lt;F5&gt; with something else like &lt;leader&gt;u if you prefer. Make sure to read the help file for Gundo, there’s several settings in there you can tweak. This is probably a good time to explain mappings and why I chose that particular string of characters. map is the most primitive way in Vim to make a key map to a certain command or function, but map is recursive and this is usually an undesired effect, so noremap, as in “non-recursive” map is usually used. nnoremap (notice the extra n at the beginning) is a non-recursive map in normal mode. I used &lt;silent&gt; here because I don’t prefer to have the command print in the command prompt. I add the &lt;Esc&gt; to make sure the :ex command is entered exactly as intended and there weren’t any previously entered characters like numbers added that might cause undesired effects. The &lt;CR&gt; at the end is short for ‘carriage return’, which is how you tell Vim to push enter and actually execute the command. Vim-sensible enables incsearch which highlights the first match as you type, which is great and all, but there’s a pretty awesome plugin that expands on this power to not just highlight the first match, but all visible matches on the screen, which is extremely handy for writing regex. (Again, make sure to check the help file!) A note on organization: Your vimrc can quickly become a jumbled mess if you’re not careful, so I find it helps to group things into folds. For instance, in my vimrc, I use several settings for this plugin, so directly underneath the plugin definition I add the settings and then wrap the whole block in a fold. This lets me use zc to close the fold (which hides the contents), and then zo to open it (or zm/zr to increase/decrease the foldlevel). The entire block looks like so: Plug 'haya14busa/incsearch.vim' \" &#123;&#123;&#123; map / &lt;Plug&gt;(incsearch-forward) map ? &lt;Plug&gt;(incsearch-backward) map g/ &lt;Plug&gt;(incsearch-stay) map n &lt;Plug&gt;(incsearch-nohl-n) map N &lt;Plug&gt;(incsearch-nohl-N) map * &lt;Plug&gt;(incsearch-nohl-*) map # &lt;Plug&gt;(incsearch-nohl-#) map g* &lt;Plug&gt;(incsearch-nohl-g*) map g# &lt;Plug&gt;(incsearch-nohl-g#) let g:incsearch#consistent_n_direction = 1 let g:incsearch#auto_nohlsearch = 1 let g:incsearch#magic = '\\v'\" &#125;&#125;&#125; One of my new favorite plugins is vim-sneak and I can’t believe how long I went without it. This overrides the s command (which is really just a shortcut for xi) to provide a motion that lets you jump to the next two characters you give it. If you’ve seen EasyMotion (which I strongly dislike), it’s similar to that but faster and more lightweight, and actually provides a motion for use with operators (instead of just moving your cursor). It can also extend f/F/t/T/;/, to work across multiple lines which is killer. Be sure to read the :help file for it (have I said this enough yet?), there’s some settings you’ll definitely want to play with. The settings I use for this are: Plug 'justinmk/vim-sneak' \" &#123;&#123;&#123; let g:sneak#prompt = '(sneak)» ' map &lt;silent&gt; f &lt;Plug&gt;Sneak_f map &lt;silent&gt; F &lt;Plug&gt;Sneak_F map &lt;silent&gt; t &lt;Plug&gt;Sneak_t map &lt;silent&gt; T &lt;Plug&gt;Sneak_T map &lt;silent&gt; ; &lt;Plug&gt;SneakNext map &lt;silent&gt; , &lt;Plug&gt;SneakPrevious\" &#125;&#125;&#125; targets.vim is a very cool plugin that provides some extra modifiers and text-objects to operate on. Vim-surround adds the surround text-object, and while Vim provides you with ci) to “change inside parenthesis”, this really only works if your cursor is inside the parenthesis. Targets provides (among many other things) modifiers like cin) to “change inside next parenthesis”. You’ll have to read the help file for all of the features it provides. Since text-objects are arguably Vim’s most compelling feature, why not take advantage of the ability to create our own? kana/vim-textobj-user/wiki has a list of dozens of custom text-objects you can install, and of course the engine gives you the ability to create your own. Fancy suggestions Determining whether a file is using tabs or spaces consistently isn’t always easily done visually, but Vim has a few features for handling non-visible chars. You’ll want to check the help files for more information. set list listchars=tab:\\›\\ ,trail:★,extends:»,precedes:«,nbsp:•\"\" set listchars+=eol:↵ \"\" uncomment this line if you want to show end of line charsset fillchars=stl:\\ ,stlnc:\\ ,vert:│,fold:\\ ,diff:- As far as looks go in Vim, compared to more modern editors, it’s not exactly the nicest to look at. There are a dozens plugins that attempt to spice up Vim’s interface, I have found Airline very attractive to look at and very functional while not being too heavy on resources. On top of having a nice statusline at the bottom telling you which mode you’re in (and changing colors accordingly), it will also list all of your open buffers or tabs in the tabline. If that’s too fancy for you, you can play with the ruler, which by default only shows the current line number and column, but you can put many things in the ruler: set rulerformat=%30(%=\\:b%n%y%m%r%w\\ %l,%c%V\\ %P%) If you want to learn how all the syntax works, check out :h statusline. Code specific plugins If you’re like me and you spend a lot of time using Vim to write code you’ll probably want to make it behave a bit like an IDE, and get some syntax checking and/or code completion added to Vim. Syntastic is the de-facto syntax linter for Vim. ‘Nuff said. Next I recommend using snippets. Snippets are shortcuts allow you to, for instance, type function&lt;C-k&gt; and have Vim move your cursor around while you fill in the blanks. There are two major choices: ultisnips and neosnippet. Honestly I never tried ultisnips, mostly because neosnippet ties in nicely together with the completion engine I use. Keep in mind both of those are just the engine, there are separate plugins for the actual libraries. As always, check the README. When it comes to code-completion, there are many choices, and some of them have drawbacks compared to others, so you’ll really want to spend a little time playing with each and see which you prefer most. I’ve narrowed it down to two: YouCompleteMe - Perhaps the most popular, this is really good at completion for C-languages and also works for Python and has support for a few other languages. It’s pretty heavy (read slow) and depends on clang. NeoComplete - This is the one I use, mostly because I don’t work with C-languages and it seems to function how I’d expect. This requires a somewhat newer version of Vim that’s been built with Lua support. NeoComplCache is similar but doesn’t have the same dependencies nor the same feature set. It’s also possible to use YouCompleteMe if clang is available, or attempt NeoComplete if it can, and fall-back to NeoComplCache if all else fails, so I wrote a gist for this idea. If you do web development then you’ll most definitely want emmett.vim which is more of a text expander: it lets you write CSS-style selections and then expands them in to the markup it requires. For example ul&gt;li*2 expands to &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; (but with linebreaks and indention). There are several linters and extensions for all kinds of languages, a quick search of something like “vim [languauge] plugin” should bring up several, so I won’t get to far into those, but I do have a few more for you: delimitMate - this will add matching parenthesis, quotes, braces, brackets as soon as you type the first one. I cry whenever I use Vim and this isn’t available. endwise - provides a few closing lines for things like if, for, function, etc in several languages commentary - provides a gc verb for commenting lines with motions or selections fugitive - another one of tpope’s great contributions, it may very well be the best Git wrapper of all time. git-gutter - a handy companion to fugitive that shows diff signs from the current commit beside line numbers gist - speaking of Git, it’s often really handy to send a file or just a selection of a file to gist to share with people. This plugin does that very nicely browserlink - another handy one for web developers, this will update your browser whenever you save HTML/CSS/JS files and doesn’t always require a full page refresh. filebeagle - if you’ve come from IDE-land you may be tempted to try and find some sort of file browser for Vim. NERDtree is one of the more popular choices for this, but it uses splits which can be disruptive to your other splits, and personally just does too much. I’ve been using filebeagle which does two things: lists and opens files. Even more plugins A popular choice for many users is CtrlP, which lets you fuzzy filter through files, buffer, tags, etc. It’s pretty simple and lightweight, and many users love it. Unite.vim, which attempts to “Unite” plugins in Vim by providing a common interface is similar to CtrlP, but is a bit more ambitious. It can filter through files and buffers, and also your register list, yank history, and more (there’s plugins for this plugin). Out of the box it provides no mappings, you will have to define your own. It will take some time configuring (and possibly/probably a bit of head scratching), but it is a very powerful plugin. I’ve spent a little time with both the previous plugins and lately have been using fzf to replace both of them. Fzf isn’t actually a Vim plugin (although Junegunn has made an extension for it), but a generic fuzzy filter program, that reads stdin and prints selections to stdout, so it can be used with any program. I use Vim inside tmux almost exclusively, so instead of making a split in Vim I use fzf to make splits in tmux, and do all sorts of searching. I’ve never used Sublime Text, but I found a plugin that tries to implement it’s multiple cursors feature, which is useful for all kinds of things, especially variable renaming. If you use tmux you might want some integration with it and REPLs in other panes. There are lots of these plugins that do things slightly differently so you should try a few and find one that does what you like. I use tmuxify because it was the first I found that worked how I expected. Personal tweaks If you have a lot of &lt;leader&gt; key mappings, you might find that the default \\ key can be a bit hard to reach. Well, the space bar doesn’t really do much besides advance the cursor one char, just like l does, so I think it’s a great candidate for being mapleader. let g:mapleader = \"\\&lt;Space&gt;\" The default behavior of Y is to yank the entire line (which can be done with yy), but I like Y to behave more like C and D, which work from the cursor to the end of the line. nnoremap Y y$ When searching with n and N I often find it difficult to see exactly where the next search was, so I use zt to put that line at the top of the scrolling area (or zz to center the line). Sometimes the search is inside a fold that I have to open with zv to see it. At some point I realized I do this so often that I should really just make it my default behavior: nnoremap n nzvztnnoremap N Nzvzt note that if you’re using incsearch to handle all of your searching you’ll have to add the zvzt to the end of that plug mapping If you’ve used Vim with wrapped text, you may have noticed that j and k don’t quite behave as expected, as they jump literal lines and not visible lines, which is done with gj and gk. I thought it would be handy to have a function to swap them around as needed, so here it is: function! Togglegjgk() if !exists(\"g:togglegjgk\") || g:togglegjgk==0 let g:togglegjgk=1 nnoremap j gj nnoremap k gk nnoremap gk k nnoremap gj j echo 'j/k swapped with gj/gk' else let g:togglegjgk=0 nunmap j nunmap k nunmap gk nunmap gj echo 'normal j/k' endifendfunctionnnoremap &lt;silent&gt; &lt;leader&gt;tgj &lt;Esc&gt;:call Togglegjgk()&lt;CR&gt; Early in the text I mentioned autocmd, which is a very powerful feature in Vim. They do have some caveats to be aware of, and the syntax is slightly strange at first, so check out :h autocmd. Any time your vimrc is re-sourced Vim will re-add your autocmds to it’s list, so it’s good to wrap them in either an augroup to clear them, or a condition to not re-load them (I opt for the former). Here’s a quick sample of how to :source your vimrc whenever it’s saved, and, if you’re using Airline, fix a strange quirk it has when re-sourcing: augroup VIM autocmd! autocmd BufWritePost ~/.vimrc \\ source ~/.vimrc | \\ if exists(':AirlineRefresh') | \\ AirlineRefresh | \\ endifaugroup END Because help files are so helpful in Vim, I find myself reading them a lot (and hopefully you have been too), but by default most of the help splits are horizontal (which makes no sense to me), so I have a couple autocmds for dealing with them. The first is to try and make all help splits vertical on the far right side and resized to 80 columns, and the other uses the :help &lt;C-r&gt;&lt;C-w&gt; trick we used earlier and binds it to K, which by default runs man on the word your cursor is in. Again, this would go inside the augroup above: autocmd FileType help\\ wincmd L |\\ vert resize 80autocmd FileType Vim\\ nnore &lt;silent&gt;&lt;buffer&gt; K &lt;Esc&gt;:help &lt;C-R&gt;&lt;C-W&gt;&lt;CR&gt; You can also use an autocmd to load your last known cursor position whenever a file is read. Put this inside the block above. autocmd BufReadPost *\\ if line(\"'\\\"\") &gt; 0 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") |\\ exe 'normal! g`\"zvzz' |\\ endif If you want your Vim settings to be more portable, it’s possible to use your .vimrc to recreate your whole ~/.vim directory. This block will create missing directories and install Vim-plug and the rest of your missing plugins: (works best at the top of the file) if empty(glob('~/.vim')) silent !mkdir -vp ~/.vim/&#123;autoload,bundle,cache,undo,backups,swaps&#125; silent !curl -fLo ~/.vim/autoload/plug.vim \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim source ~/.vim/autoload/plug.vim autocmd VimEnter * PlugInstallendif Closing windows can be done a few different ways in Vim. :q will close the window and exit Vim if it’s the only window open, :bd will delete the current buffer from memory but it will leave the window showing. &lt;C-w&gt;q will close the window but it won’t remove the buffer, and that’s without bringing tabs into it. That’s a lot of thinking for a simple task, and keystroke or two more than I care for. Sayonara is a plugin that attempts to simplify this process with two commands: :Sayonara which removes the buffer and closes the window, and :Sayonara! (with the exclamation!) which removes the buffer but preserves the window. That’s a lot more typing, so it needs a key-binding. The Q key starts you in :ex mode which is more often used on accident, and you can still get to this by typing gQ in normal mode, so I wrote this little function to override it and close buffers by typing QY, Qy, or Qc: function! PromptQuit() echo 'Y - kill buffer and current window' echo 'y - kill buffer but preserve window' echo 'c - kill window but preserve buffer' echo 'close current buffer? ' let char = nr2char(getchar()) if char ==# 'Y' Sayonara elseif char ==# 'y' execute 'Sayonara!' elseif char ==? 'c' wincmd q endif silent! redraw!endfunctionnnoremap &lt;silent&gt; Q &lt;Esc&gt;:call PromptQuit()&lt;CR&gt; Keep in mind that closing the last only window will also close Vim. My last suggestion, which is not a tweak for Vim per-se, but is extremely beneficial for Vim users, is to swap your caps-lock and escape keys around. I mean, who actually makes consistent use of caps lock to want it on the home row within pinky’s reach? That space would be much better suited for the escape key, and is actually how Bill Joy, the original author of vi expected the keyboard layout to be. Xmodmap will swap them out very easily and at a low enough level that no other programs are any wiser. You’ll want to put this in a file called ~/.xmodmap: remove Lock = Caps_Lockkeysym Caps_Lock = Escapekeysym Escape = Caps_Lockadd Lock = Caps_Lock Then, to use this configuration, run xmodmap ~/.xmodmap. If you use an ~/.xinitrc you’ll probably want to add that to it. You may even want to look into xcape, which can make your caps-lock key function as escape when pressed by itself, or act as control when used as a modifier with another key. //TODO:this is still a work in progress more cool Vim tricks further reading my vimrc Learn Vimscript the Hard Way","raw":null,"content":null,"categories":[{"name":"computers","slug":"computers","permalink":"http://danielfgray.github.io/computers/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://danielfgray.github.io/tags/vim/"}]},{"title":"Fuzzy searching for MPD in Bash","slug":"fzmp","date":"2014-11-02T05:00:00.000Z","updated":"2016-06-04T21:27:49.913Z","comments":true,"path":"computers/fzmp/","link":"","permalink":"http://danielfgray.github.io/computers/fzmp/","excerpt":"","keywords":null,"text":"I recently came across fzf, which is an interactive line filter. By default fzf will fuzzy search recursively through file names in the current directory, but it also filters through stdin. Realizing it was a generic filter, and not just for files, I wondered what else I could fuzzy search through, and, being a musician, I felt that filtering through my music library would be handy. mpc is a CLI interface to mpd, and after reading through the man page), I find that mpc listall will display a list of every song in the mpd database (although later on I learned it’s actually bad practice). So immediately I ran mpc listall | fzf, which worked as I expected. Only, fzf just prints the selection to stdout, it doesn’t have any side-effects besides printing to stdout. So after reading the man page some more and tinkering around, I learn that mpc add will take files from stdin and add them to the bottom of the playlist. So mpc listall | fzf | mpc add will list all available files in the mpd database, fuzzy filter through them, then add to the bottom of the playlist. Unfortunately, that still doesn’t actually play the added song, and mpc play will only play whatever song is currently selected in the queue, rather than the new song. In the end I found that mpc play accepts an integer as an index from the playlist. So, if mpc add puts them at the bottom, I need to know how many songs are in the playlist, which I can achieve with mpc playlist | wc -l (wc is wordcount, the -l switch counts lines). At this point my code is better suited to a script rather than a one-liner like: mpc listall | fzf | mpc add &amp;&amp; mpc play $(mpc playlist | wc -l) Which has some weird quirks if you don’t actually add a song. And what if I want to add multiple songs? fzf has the -m switch to select multiple lines, and mpc add happily adds as many songs as you give it. After talking to #bash on freenode they pointed out we’d be better off using an array for multiple files, and mapfile is perfect for this. The biggest benefit to using an array here is that I have built-in functionality for counting the elements, rather than repeatedly calling wc -l. mapfile -t songs &lt; &lt;(mpc listall | fzf -m) will create a variable called $songs as an array with all the lines as individual elements. We’re also using process substitution here because mapfile expects stdin, but the input is a command, so I use the &lt;() penguin-looking syntax to trick mapfile into thinking the command is really a file . Bash’s quirky array syntax gives us ${songs[@]} as a reference to all items in the array, and $(#songs[@]) to count the amount of items in the $songs array. And with all of this information I have all the pieces to make a fuzzy music finder. Using the array, I want to pass each element as a string separated by a newline. This can be done with a little printf magic: printf &#39;%s\\n&#39; &quot;${songs[@]}&quot; and that is easily piped into mpc add. If I assign a variable to the length of the playlist (which I got with mpc playlist | wc -l) I can tell mpc play to play the last song in the playlist. But if I select multiple songs, I want it to start playing the first of them, so I need a little bit of simple math to figure out how many songs back to start from the bottom. So if the array is longer than one item, I want to reassign the index variable to the length of the playlist, minus however many items I added from the $songs array, and add one (because without adding one I would just have the last item in the playlist before I added anything). So, putting it all together I came up with this: mapfile -t songs &lt; &lt;(mpc search -f '[%artist% - [%album% - ][%track% - ][%title%]]|%file%' filename '' | fzf -m)(( $&#123;#songs[@]&#125; &gt; 0 )) || exitprintf '%s\\n' \"$&#123;songs[@]&#125;\" | mpc -q addindex=$(mpc playlist | wc -l)(( $&#123;#songs[@]&#125; &gt; 1 )) &amp;&amp; index=$(( $index - $&#123;#songs[@]&#125; + 1))mpc -q play \"$index\" I replaced listall with search since that’s considered the ‘best’ way, and added some formatting to the output so it prints tag info rather than just the filename. The full script I wrote is a lot more involved and adds filter by artist then by album, as well as filtering the playlist, but this was the core functionality I came up with. I hope this was as educational to you as it was fun for me to make!","raw":null,"content":null,"categories":[{"name":"computers","slug":"computers","permalink":"http://danielfgray.github.io/computers/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://danielfgray.github.io/tags/linux/"},{"name":"bash","slug":"bash","permalink":"http://danielfgray.github.io/tags/bash/"},{"name":"fzf","slug":"fzf","permalink":"http://danielfgray.github.io/tags/fzf/"},{"name":"mpd","slug":"mpd","permalink":"http://danielfgray.github.io/tags/mpd/"}]},{"title":"Backporting packages in Debian","slug":"debian-backporting","date":"2013-10-22T05:00:00.000Z","updated":"2016-05-20T05:04:25.778Z","comments":true,"path":"computers/debian-backporting/","link":"","permalink":"http://danielfgray.github.io/computers/debian-backporting/","excerpt":"","keywords":null,"text":"Are you anxious for a new version of a particular package, and don’t want to wait for someone else to submit it to backports?After a few hours of reading docs and testing this out myself I feel like I’ve gotten a good grasp on how to do this yourself. First, you want to add sources to your repos if you don’t have them. You want at least one or more of the following lines in /etc/apt/sources.list: deb-src http://http.debian.net/debian stable maindeb-src http://http.debian.net/debian testing maindeb-src http://http.debian.net/debian unstable maindeb-src http://http.debian.net/debian experimental main After adding those, make sure to apt-get updateThen, if you don’t have a build directory, make one and cd, mkdir ~/build &amp;&amp; cd ~/build Now here’s the interesting part: apt can download the source for the program you want. You’ll want to search for the available versions using apt-cache showsrc &lt;package&gt; | less and take note of the version number. Before you begin you’ll want to make sure you have all the build dependencies installed, so be sure to run apt-get build-dep &lt;package&gt;. After you’ve done that, run apt-get source -b &lt;package&gt;=&lt;version&gt;. This will download the source code and whatever patches the Debian maintainers have added and begin compiling. It is most definitely possible to ./configure the package manually, but it’s a bit tricky. To not automatically start compiling, omit the -b flag from apt-get source, and after the source is finished downloading, cd to the source and edit debian/rules, and then run dpkg-buildpackage. Once it’s done it will create a Debian package, install it with dpkg -i &lt;package&gt;.deb And there you have it! tl;dr apt-cache showsrc &lt;package&gt;sudo apt-get build-dep &lt;package&gt;apt-get source -b &lt;package&gt;=&lt;version&gt;sudo dpkg -i &lt;package&gt;.deb It should be noted that this is not fool-proof, some packages will fail to build for various reasons, most often the build dependencies might require newer versions than are available from the repos, in which case you have to start down another path of backporting the dependencies, which can sometimes lead to backporting dependencies of dependencies..","raw":null,"content":null,"categories":[{"name":"computers","slug":"computers","permalink":"http://danielfgray.github.io/computers/"}],"tags":[{"name":"debian","slug":"debian","permalink":"http://danielfgray.github.io/tags/debian/"},{"name":"linux","slug":"linux","permalink":"http://danielfgray.github.io/tags/linux/"}]}]}